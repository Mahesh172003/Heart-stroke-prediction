# -*- coding: utf-8 -*-
"""ml heartstroke final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cjLO3-mF13bvSCJFMG-e0xbK5kwy1NN_
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
# %matplotlib inline

df = pd.read_csv('/content/healthcare-dataset-stroke-data.csv')

df

df.columns

df.shape

df.info()

df.describe()

df.dtypes

df.iloc[5105][:]

df['gender'].value_counts()

df['ever_married'].value_counts()

df['Residence_type'].value_counts()

df['work_type'].value_counts()

df['smoking_status'].value_counts()

"""# Visualization"""

plt.rcParams['figure.figsize']=(12.0,9.0)
x=df.iloc[:]['avg_glucose_level'].values
plt.boxplot(x)
plt.title("Avg_glucose_level")
plt.grid()
plt.show()

sns.distplot(x=x)
plt.title("Avg_glucose_level")

plt.rcParams['figure.figsize']=(12.0,9.0)
sns.lineplot(x="avg_glucose_level", y="stroke", data=df)

sns.lmplot(x='avg_glucose_level',y='stroke',data = df)

x1=df.bmi
plt.boxplot(x1)
plt.grid()
plt.show()

sns.distplot(x=x1)

x2=df.iloc[:]['age'].values
plt.boxplot(x2)
plt.title("Age")
plt.grid()
plt.show()

sns.distplot(x=x2)

plt.rcParams['figure.figsize']=(12.0,9.0)
sns.barplot(x='smoking_status', y='stroke', data=df)
plt.show()

sns.scatterplot(data=df[['age','bmi','smoking_status','hypertension','heart_disease','Residence_type','work_type','gender']])

sns.jointplot(x='avg_glucose_level',y='bmi',color="blue",data=df)

sns.pairplot(data=df)

sns.heatmap(df.corr())

"""# Feature Engineering"""

df.groupby(['stroke']).stroke.count()

df.groupby(['smoking_status']).smoking_status.count()

df.isnull().sum()

sns.heatmap(df.isnull(),yticklabels=False,cbar=False,cmap='viridis')

mean_val=df['bmi'].mean()
df['bmi'].fillna(value=mean_val,inplace=True)

df.isnull().sum()

sns.heatmap(df.isnull(),yticklabels=False,cbar=False,cmap='viridis')

from sklearn.preprocessing import LabelEncoder 
le = LabelEncoder()
df['stroke'] = le.fit_transform(df['stroke'])
sns.set(style ="darkgrid")
sns.countplot(df['stroke'])

!pip install imblearn

from imblearn.over_sampling import RandomOverSampler

oversample = RandomOverSampler(sampling_strategy='minority')

X=df.iloc[:,:-1]
X

y=df.iloc[:,-1]
y

X_over, y_over = oversample.fit_resample(X, y)

new_df=pd.concat((X_over,y_over),axis=1)
new_df

new_df.groupby('stroke').stroke.count()

from sklearn.preprocessing import LabelEncoder 
le = LabelEncoder()
new_df['stroke'] = le.fit_transform(new_df['stroke'])
sns.set(style ="darkgrid")
sns.countplot(new_df['stroke'])

df.isnull().sum().sum()

from sklearn import preprocessing
  
label_encoder = preprocessing.LabelEncoder()
  
new_df['Residence_type']= label_encoder.fit_transform(new_df['Residence_type'])
  
new_df['Residence_type'].unique()

from sklearn import preprocessing
  
label_encoder = preprocessing.LabelEncoder()
  
new_df['ever_married']= label_encoder.fit_transform(new_df['ever_married'])
  
new_df['ever_married'].unique()

from sklearn import preprocessing
  
label_encoder = preprocessing.LabelEncoder()
  
new_df['smoking_status']= label_encoder.fit_transform(new_df['smoking_status'])
  
new_df['smoking_status'].unique()

from sklearn import preprocessing
  
label_encoder = preprocessing.LabelEncoder()
  
new_df['gender']= label_encoder.fit_transform(new_df['gender'])
  
new_df['gender'].unique()

from sklearn import preprocessing
  
label_encoder = preprocessing.LabelEncoder()
  
new_df['work_type']= label_encoder.fit_transform(new_df['work_type'])
  
new_df['work_type'].unique()

new_df

new_df.drop('id',inplace=True,axis=1)

sns.heatmap(new_df.corr())

sns.scatterplot(data=new_df)

sns.pairplot(data=new_df)

"""# Logistic Regression"""

new_df.columns

x=new_df[["age","avg_glucose_level","bmi"]]
y=new_df["stroke"]

from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()
scaler.fit(x)
x_scaled = scaler.transform(x)

from sklearn.preprocessing import LabelEncoder
label_encoder = LabelEncoder()
y = label_encoder.fit_transform(y)

from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test= train_test_split(x_scaled, y, test_size=0.2, random_state=42)

from sklearn.linear_model import LogisticRegression
clf = LogisticRegression()
clf.fit(x_train, y_train)

y_pred = clf.predict(x_test)

from sklearn.metrics import accuracy_score
from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
accuracy = accuracy_score(y_test, y_pred)
print("Accuracy: {:.2f}%".format(accuracy * 100))
precision=precision_score(y_test,y_pred)
print("precision:",precision)
recall =recall_score(y_test,y_pred)
print("recall:",recall)

# Confusion Matrix
from sklearn.metrics import confusion_matrix
cf = confusion_matrix(y_test, y_pred)
plt.figure()
sns.heatmap(cf, annot=True)
plt.xlabel('Prediction')
plt.ylabel('Target')
plt.title('Confusion Matrix')

X1=new_df[['age','hypertension','heart_disease','ever_married','Residence_type','avg_glucose_level','bmi','gender']]
y1=new_df['stroke']

from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()
scaler.fit(X1)
X1_scaled = scaler.transform(X1)

from sklearn.preprocessing import LabelEncoder
label_encoder = LabelEncoder()
y1 = label_encoder.fit_transform(y1)

from sklearn.model_selection import train_test_split
X1_train, X1_test, y1_train, y1_test= train_test_split(X1_scaled, y1, test_size=0.2, random_state=42)

from sklearn.linear_model import LogisticRegression
clf = LogisticRegression()
# training the model
clf.fit(X1_train, y1_train)

y1_pred = clf.predict(X1_test)

y1_pred = clf.predict(X1_test)

from sklearn.metrics import accuracy_score
from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
accuracy = accuracy_score(y1_test, y1_pred)
print("Accuracy: {:.2f}%".format(accuracy * 100))
precision=precision_score(y1_test,y1_pred)
print("precision:",precision)
recall =recall_score(y1_test,y1_pred)
print("recall:",recall)

from sklearn.metrics import confusion_matrix
cf = confusion_matrix(y_test, y_pred)
plt.figure()
sns.heatmap(cf, annot=True)
plt.xlabel('Prediction')
plt.ylabel('Target')
plt.title('Confusion Matrix')

"""##  KNN"""

from sklearn.model_selection import train_test_split

X=new_df[["age","avg_glucose_level","bmi"]]
y=new_df["stroke"]

estimator.fit(X_train)

from sklearn.neighbors import LocalOutlierFactor
lof = LocalOutlierFactor(novelty=True)
lof.fit(X_train)

df.predict(X_test)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=1)

## Finetuning the hyperparameter K

from sklearn.neighbors import KNeighborsClassifier

error1= []
error2= []
for k in range(1,15):
    knn= KNeighborsClassifier(n_neighbors=k)
    knn.fit(X_train,y_train)
    y_pred1= knn.predict(X_train)
    error1.append(np.mean(y_train!= y_pred1))
    y_pred2= knn.predict(X_test)
    error2.append(np.mean(y_test!= y_pred2))

# plt.figure(figsize(20,10))
plt.plot(range(1,15),error1,label="train")
plt.plot(range(1,15),error2,label="test")
plt.xlabel('k Value')
plt.ylabel('Error')
plt.legend()

## Model Creation

knn = KNeighborsClassifier(n_neighbors=8)

## Model Training

knn.fit(X_train, y_train)

from sklearn.metrics import confusion_matrix
y_pred = knn.predict(X_test)
cm = confusion_matrix(y_test, y_pred)
cm

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib.pyplot as plt
import seaborn as sn
plt.figure(figsize=(7,5))
sn.heatmap(cm, annot=True)
plt.xlabel('Predicted')
plt.ylabel('Truth')

from sklearn.metrics import accuracy_score
from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
accuracy = accuracy_score(y_test, y_pred)
print("Accuracy: {:.2f}%".format(accuracy * 100))
precision=precision_score(y_test,y_pred)
print("precision:",precision)
recall =recall_score(y_test,y_pred)
print("recall:",recall)

from sklearn.metrics import classification_report

print(classification_report(y_test, y_pred))